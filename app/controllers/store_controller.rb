# StaticPagesController.rb
# 
# Class was originally generated by rails 3.2.8 
# Modified by Dan Laffan (12111619) starting 23rd November 2012.
#
# Note 1: Search attribute based on code demonstrated by Wesley Gorman
#         in NCI lecture, and subsequently modified by Dan Laffan.
#
# Copyright Â© 2012, Julian Arnold and Daniel M. Laffan.  All rights reserved.
# Rights in third party code acknowledged.

class StoreController < ApplicationController

  before_filter :get_variables, :except => 'search'

  def index # see all finished products
    
    if @special_occasions
      @special_occasion = SpecialOccasion.first(conditions: ["name = ? and visible_to_customers = ?", params[:show], true])
    end
    
    if @special_occasion
      @finished_products = @special_occasion.finished_products.paginate(order: "running_order, created_at DESC", :page => params[:page], :per_page => 7)
    else # params[:show] == "latest" or !params[:show] or params[:show] not known
      @finished_products = FinishedProduct.paginate(order: "running_order, created_at DESC", :page => params[:page], :per_page => 7)
      @finished_product = nil
    end
  end

  def show # see details on one finished product
    @finished_product = FinishedProduct.find_by_product_name(params[:product_name].gsub("_"," "))
    if @finished_product
      # go to the usual show.html.erb
      @special_occasion = @finished_product.special_occasion
    else
      redirect_to root_url, :notice => "Sorry, we couldn't find that product."
    end
  end

  def search # search finished products and (component) products
    @finished_products = FinishedProduct.search(params[:search_query])
    @products = Product.search(params[:search_query])
    render :search_results
  end

  def design_my_cake # Gives users the HTML form to customise a NEW CAKE
    # get or create the current shopping cart
    @current_cart = current_cart
    if !@current_cart # If there is no cart in existence already...
      # create a new cart
      @current_cart = ShoppingCart.new
      if current_user and current_user.customer
        @current_cart.customer_id = current_user.customer.id
      end
      @current_cart.shopping_cart_status_id = ShoppingCartStatus.first(:conditions => ["active_cart = ?", true]).id
      @current_cart.pay_pal_status_id = 0
      @current_cart.save
      session[:shopping_cart_id] = @current_cart.id
    end
    
    # builds an empty @cake
    @cake = @current_cart.cakes.new
    @cake.cake_required_at = Time.now.gmtime.to_date + 2.weeks + 20.hours
    if params[:fp] and params[:fp].to_i > 0
      fp = FinishedProduct.find(params[:fp].to_i)
      if fp
        @cake.based_on_finished_product_id = fp.id
      end
    end
  end

  def edit_my_cake # edit the shopping_cart_items for an existing cake
    @cake = current_cart.cakes.find(params[:cake_id].to_i)
    if @cake
      render 'design_my_cake'
    else
      redirect_to root_url, :notice => "Sorry, you can't edit that cake"
    end
  end

  def add_this_to_the_cart # create a cake
    cart = current_cart # By the time Ruby gets here, we have a cart.

    # First thing is to build the cake
    # ================================
    # Cake is the intermediate level object between a shopping_cart and a collection of
    # individual shopping_cart_items
    #
    # cake => {"based_on_finished_product_id"=>"371", "cake_required_at(3i)"=>"1", "cake_required_at(2i)"=>"1", "cake_required_at(1i)"=>"2013",
    #          "cake_required_at(4i)"=>"20", "cake_required_at(5i)"=>"00", "special_occasion"=>"Birthday", 
    #          "name_to_appear_on_cake"=>"Happy birthday Billy", "general_description_from_customer"=>"A cake in the shape of the space shuttle"},
    if @cake and @cake.id.to_i > 0
      # We're here because we were rerouted from the 'edit' processor, 
      # a method called 'update_cake_design'
      @cake.assign_attributes(params[:cake])
    else
      @cake = cart.cakes.new(params[:cake])
    end
    # @cake.shopping_cart_id     - gets set by the cart.cakes.new line.
    # @cake.production_quotum_id - will be set by a before_validation callback
    # @cake.weekday              - will be set by a before_validation callback
    cake_okay = @cake.valid? # should be FALSE as production_quotum hasn't been completd.
    @cake.save

    # Next, the difficult part; stepping through the params[:product] stuff for every possible product
    # ================================================================================================
    # First thing is to pick up the counter we created in the ERB execution of the HTML FORM
    product_counter = params[:product_counter].to_i # e.g., 13
    
    # Next, I will step through the params[:product] looking for products from (say) 0..13.
    product_looper = 0

    # There are a finite number of options that the user can take in the HTML form,
    # and product_counter knows how many.
    while product_looper < product_counter do
      # If the user has chosen to purchase product #-product_looper, there'll be a
      # params[:product] for it.
      
      # the_param is just a handy way of not repeating myself:
      the_param = ":#{product_looper.to_s}"
      
      if cake_okay and params[:product] and params[:product][the_param]
        # So, the user has chosen to purchase params[:product][:product_looper]
        
        # let's create a line-item.
        shopping_cart_item = @cake.shopping_cart_items.new

        # Go find the product they have chosen
        product = Product.find(params[:product][the_param].to_i)
        if product
          shopping_cart_item.product_id       = product.id
          shopping_cart_item.unit_price       = product.current_price.price.to_f
          shopping_cart_item.product_price_id = product.current_price.id
          shopping_cart_item.quantity         = 1 # set up a default value
          # Next, let's see if there are any extra options for this product in the params.
          if params[:product][product_looper.to_s][product.id.to_s]
            
            if params[:product][product_looper.to_s][product.id.to_s]["description"]
              shopping_cart_item.user_description = params[:product][product_looper.to_s][product.id.to_s]["description"]
            end
            if params[:product][product_looper.to_s][product.id.to_s]["quantity"]
              shopping_cart_item.quantity = params[:product][product_looper.to_s][product.id.to_s]["quantity"].to_i
            end
            if params[:product][product_looper.to_s][product.id.to_s]["choice"]
              shopping_cart_item.product_options_list_choice = params[:product][product_looper.to_s][product.id.to_s]["choice"]
            end
          end
        end
        
        shopping_cart_item.line_total = shopping_cart_item.unit_price.to_f * shopping_cart_item.quantity
        shopping_cart_item.save
        
      end # of "if params[:product] and params[:product][(product_looper.to_s).to_sym]"
      product_looper += 1
    end
    
    # Next task is to find any globally-assigned dropdown list values
    # ===============================================================
    #
    # All (ingredient) products are attached to a category.  Some categories have a global variable that
    # should be tagged onto whichever ingredient product is selected for a cake.
    categories = ProductCategory.all
    categories.each do |category|
      if params[("category_" + category.id.to_s).to_sym]
        # We're here because the user supplied a choice 
        the_shopping_cart_item = @cake.shopping_cart_items.find(:first, :include => "product", :conditions => ["products.product_category_id = ?", category.id.to_i])
        if the_shopping_cart_item
          puts "made it in here"
          the_shopping_cart_item.global_options_list_choice = params[("category_" + category.id.to_s).to_sym].to_s
          the_shopping_cart_item.save
        end
      end
    end
    
    # Finally, redirect the user to the "show_cake" page
    # ==================================================
    #
    # From there, they can continue shopping (home page) or checkout_now.
    #
    if @cake.errors.messages.size > 0
      # still some errors
      render "design_my_cake", :notice => "Sorry, something went wrong. Some required fields were left out."
    else
      # everything's okay
      render "show_cake", :notice => "You have successfully added a cake to your shopping cart.<br/>Thank you!"
    end
  end

  def show_cart # show a user a specific cart, live or not, reqested by params[:cart_id]
    if current_user and current_user.customer
      @shopping_cart = current_user.customer.shopping_carts.find(params[:id].to_i)
    else
      @shopping_cart = current_cart
    end
  end

  def show_cake # shows an individual cake
    if current_user and current_user.customer
      @cake = Cake.find(:first, :include => "shopping_cart", :conditions => ["cakes.id = ? and shopping_carts.customer_id = ?", params[:id].to_i, current_user.customer.id])
    else
      @cake = current_cart.cakes.find(params[:id])
    end
    render 'show_cake'
  rescue ActiveRecord::RecordNotFound
    redirect_to root_url, :notice => "Sorry, couldn't find that."
  end

  def update_cake_details # just the header details
    @cake = current_cart.cakes.find(params[:id])
    if @cake and @cake.update_attributes(params[:cake])
      flash[:notice] = "Your cake's details have been updated."
    else
      flash[:notice] = "Sorry, something went wrong and your changes weren't saved."
    end
    render 'show_cake'
  end

  def update_cake_design # change the makeup of a cake design
    # Verify that @cake would be valid if updated:
    @cake = current_cart.cakes.find(params[:cake][:id])
    # found the next method on Stack Overflow: http://stackoverflow.com/questions/6770350/rails-update-attributes-without-save
    @cake.assign_attributes(params[:cake]) if @cake
    if @cake and @cake.valid?
      @cake.shopping_cart_items.destroy_all
      add_this_to_the_cart
    else
      render :nothing => true
    end
  end

  def delete_cart
    @cart = current_cart
    if @cart and @cart.shopping_cart_status.active_cart == true
      if @cart.cakes.count > 0
        @cart.cakes.each do |cake|
          cake.shopping_cart_items.destroy_all
        end
      end
      @cart.cakes.destroy_all
      @cart.destroy
      flash[:notice] = "Your cart has been deleted."
    else
      flash[:notice] = "Sorry, I couldn't delete that cart as it has been processed."
    end
    redirect_to root_url
  end

  def delete_cake
    @cake = current_cart.cakes.find(params[:cake_id])
    if @cake
      @cake.destroy
      if current_cart.cakes.count == 0
        current_cart.destroy
        flash[:notice] = "Your cart is now empty."
      else
        flash[:notice] = "That cake has been removed from your cart."
      end
    end
    redirect_to root_url
  end

  def start_checkout # beginning of the checkout process
    if current_user
      if current_user.customer
        redirect_to checkout_process_url
      else
        redirect_to root_url, :notice => "You're not a customer, so you can't go through checkout."
      end
    else
      session[:checkout_started] = true
      redirect_to checkout_registration_url
    end
  end
  
  def checkout_registration
    if current_user and current_user.customer # logged in as a customer
      redirect_to checkout_process_url
    elsif current_user # logged in, not a customer (i.e., a manager or admin)
      redirect_to root_url, :notice => "You're not a cusotmer, so you can't go through checkout."
    else
      @user = User.new
      @user.build_customer
      @user_session = UserSession.new
      # this session variable is used in ApplicationController.redirect_back_or_default
      session[:return_to] = checkout_registration_url
      # render "checkout_registration.html.erb" - just so you know where you're headed
    end
  end
  
  def checkout_process
    if current_user and current_user.customer
      if current_cart
        @shopping_cart = current_cart
        user = User.find(current_user.id)
        @shopping_cart.customer_id = user.customer.id
        # The view will check that each cake fits in the production schedule
        # (managed by production_quota), and will warn (but NOT stop)
        # the user from placing an order.
        
      else
        session[:checkout_started] = nil
        redirect_to root_url, :notice => "Sorry, your cart is empty"
      end
    else
      redirect_to checkout_registration_url
    end
  end
  
  def buy_now
    cart = ShoppingCart.find(current_cart.id)
    cart.shopping_cart_status_id = ShoppingCartStatus.first(:conditions => ["paid_cart = ?", true], order: "running_order").id
    cart.save
    session.delete(:checkout_started)
    session.delete(:shopping_cart_id)
    redirect_to checkout_complete_url(:id => cart.id)
  end
  
  def checkout_complete
    session.delete(:checkout_started)
    
    @shopping_cart = ShoppingCart.find(params[:id])
    if @shopping_cart
      # render "order.confirmation.html.erb" - just so you know...
    else
      redirect_to root_url, :notice => "Sorry, couldn't find that transaction!"
    end
  end
  
  private
  
  def get_variables
    @special_occasions = SpecialOccasion.all(order: "running_order, name", conditions: ["visible_to_customers = ?", true])
    @product_categories = ProductCategory.all(order: "running_order")
    
  end

end
