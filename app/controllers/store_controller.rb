# StaticPagesController.rb
# 
# Class was originally generated by rails 3.2.8 
# Modified by Dan Laffan (12111619) starting 23rd November 2012.
#
# Note 1: Search attribute based on code demonstrated by Wesley Gorman
#         in NCI lecture, and subsequently modified by Dan Laffan.
#
# Copyright Â© 2012, Julian Arnold and Daniel M. Laffan.  All rights reserved.
# Rights in third party code acknowledged.

class StoreController < ApplicationController

  before_filter :get_variables, :except => 'search'

  def index # see all finished products
    
    if @special_occasions
      @special_occasion = SpecialOccasion.first(conditions: ["name = ? and visible_to_customers = ?", params[:show], true])
    end
    
    if @special_occasion
      @finished_products = @special_occasion.finished_products.all(order: "running_order, created_at DESC")
    else # params[:show] == "latest" or !params[:show] or params[:show] not known
      @finished_products = FinishedProduct.all(order: "running_order, created_at DESC")
      @finished_product = nil
    end
  end

  def show # see details on one finished product
    @finished_product = FinishedProduct.find_by_product_name(params[:product_name].gsub("_"," "))
    if @finished_product
      # go to the usual show.html.erb
      @special_occasion = @finished_product.special_occasion
    else
      redirect_to root_url, :notice => "Sorry, we couldn't find that product."
    end
  end

  def search # search finished products and (component) products
    @finished_products = FinishedProduct.search(params[:search_query])
    @products = Product.search(params[:search_query])
    render :search_results
  end

  def design_my_cake # Gives users the HTML form to customise a NEW CAKE
    # get or create the current shopping cart
    @current_cart = current_cart
    if !@current_cart # If there is no cart in existence already...
      # create a new cart
      @current_cart = ShoppingCart.new
      if current_user and current_user.customer
        @current_cart.customer_id = current_user.customer.id
      end
      @current_cart.shopping_cart_status_id = ShoppingCartStatus.first(:conditions => ["active_cart = ?", true]).id
      @current_cart.pay_pal_status_id = 0
      @current_cart.save
      session[:shopping_cart_id] = @current_cart.id
    end
    
    # builds an empty @cake
    @cake = @current_cart.cakes.new
    @cake.cake_required_at = Time.now.gmtime.to_date + 2.weeks + 20.hours
    if params[:fp] and params[:fp].to_i > 0
      fp = FinishedProduct.find(params[:fp].to_i)
      if fp
        @cake.based_on_finished_product_id = fp.id
      end
    end
  end

  def edit_my_cake # edit the shopping_cart_items for an existing cake
    @cake = current_cart.cakes.find(params[:cake_id].to_i)
    if @cake
      render 'design_my_cake'
    else
      redirect_to root_url, :notice => "Sorry, you can't edit that cake"
    end
  end

  def add_this_to_the_cart # create a cake
    cart = current_cart # By the time Ruby gets here, we have a cart.

    # First thing is to build the cake
    # ================================
    # Cake is the intermediate level object between a shopping_cart and a collection of
    # individual shopping_cart_items
    #
    # cake => {"based_on_finished_product_id"=>"371", "cake_required_at(3i)"=>"1", "cake_required_at(2i)"=>"1", "cake_required_at(1i)"=>"2013",
    #          "cake_required_at(4i)"=>"20", "cake_required_at(5i)"=>"00", "special_occasion"=>"Birthday", 
    #          "name_to_appear_on_cake"=>"Happy birthday Billy", "general_description_from_customer"=>"A cake in the shape of the space shuttle"},
    @cake = cart.cakes.new(params[:cake])
    # @cake.shopping_cart_id     - gets set by the cart.cakes.new line.
    # @cake.production_quotum_id - will be set by a before_validation callback
    # @cake.weekday              - will be set by a before_validation callback
    cake_okay = @cake.valid? # should be FALSE as production_quotum hasn't been completd.
    @cake.save

    # Next, the difficult part; stepping through the params[:product] stuff for every possible product
    # ================================================================================================
    # First thing is to pick up the counter we created in the ERB execution of the HTML FORM
    product_counter = params[:product_counter].to_i # e.g., 13
    
    # Next, I will step through the params[:product] looking for products from (say) 0..13.
    product_looper = 0

    # There are a finite number of options that the user can take in the HTML form,
    # and product_counter knows how many.
    while product_looper < product_counter do
      # If the user has chosen to purchase product #-product_looper, there'll be a
      # params[:product] for it.
      
      # the_param is just a handy way of not repeating myself:
      the_param = ":#{product_looper.to_s}"
      
      if cake_okay and params[:product] and params[:product][the_param]
        # So, the user has chosen to purchase params[:product][:product_looper]
        
        # let's create a line-item.
        shopping_cart_item = @cake.shopping_cart_items.new

        # Go find the product they have chosen
        product = Product.find(params[:product][the_param].to_i)
        if product
          shopping_cart_item.product_id       = product.id
          shopping_cart_item.unit_price       = product.current_price.price.to_f
          shopping_cart_item.product_price_id = product.current_price.id
          shopping_cart_item.quantity         = 1 # set up a default value
          # Next, let's see if there are any extra options for this product in the params.
          if params[:product][product_looper.to_s][product.id.to_s]
            
            if params[:product][product_looper.to_s][product.id.to_s]["description"]
              shopping_cart_item.user_description = params[:product][product_looper.to_s][product.id.to_s]["description"]
            end
            if params[:product][product_looper.to_s][product.id.to_s]["quantity"]
              shopping_cart_item.quantity = params[:product][product_looper.to_s][product.id.to_s]["quantity"].to_i
            end
            if params[:product][product_looper.to_s][product.id.to_s]["choice"]
              shopping_cart_item.product_options_list_choice = params[:product][product_looper.to_s][product.id.to_s]["choice"]
            end
          end
        end
        
        shopping_cart_item.line_total = shopping_cart_item.unit_price.to_f * shopping_cart_item.quantity
        shopping_cart_item.save
        
      end # of "if params[:product] and params[:product][(product_looper.to_s).to_sym]"
      product_looper += 1
    end
    
    
    # Before we finish, test that everything went ok, and if it did, then go ahead and save everything.
    # =================================================================================================
    # if cake_okay and ...
    # @cake.save
    # 
    
    
    # Finally, redirect the user to the "show_cake" page
    # ==================================================
    #
    # From there, they can continue shopping (home page) or checkout_now.
    #
    if @cake.errors.messages.size > 0
      # still some errors
      render "design_my_cake", :notice => "Sorry, something went wrong. Some required fields were left out."
    else
      # everything's okay
      render "show_cake", :notice => "You have successfully added a cake to your shopping cart.<br/>Thank you!"
    end
  end

  def view_cart
    @cart = current_cart
  end
  
  def show_cart # show one cart, live or not
    @cart = 1 ##################################
  end

  def show_cake
    @cake = current_cart.cakes.find(params[:id])
    render 'show_cake'
  end

  def update_cake_details # just the header details
    params[:cake].delete(:user_id) if params[:cake][:user_id]
      
    @cake = current_cart.cakes.find(params[:id])
    if @cake and @cake.update_attributes(params[:cake])
      flash[:notice] = "Your cake's details have been updated."
    else
      flash[:notice] = "Sorry, something went wrong and your changes weren't saved."
    end
    render 'show_cake'
  end

  def update_cake_design # change the makeup of a cake design
    #
  end

  def delete_cart
    @cart = current_cart
    if @cart and @cart.shopping_cart_status.active_cart == true
      if @cart.cakes.count > 0
        @cart.cakes.each do |cake|
          cake.shopping_cart_items.destroy_all
        end
      end
      @cart.cakes.destroy_all
      @cart.destroy
      flash[:notice] = "Your cart has been deleted."
    else
      flash[:notice] = "Sorry, I couldn't delete that cart as it has been processed."
    end
    redirect_to root_url
  end

  def delete_cake
    @cake = current_cart.cakes.find(params[:cake_id])
    if @cake
      @cake.destroy
      if current_cart.cakes.count == 0
        current_cart.destroy
        flash[:notice] = "Your cart is now empty."
      else
        flash[:notice] = "That cake has been removed from your cart."
      end
    end
    redirect_to root_url
  end

  private
  
  def get_variables
    @special_occasions = SpecialOccasion.all(order: "running_order, name", conditions: ["visible_to_customers = ?", true])
    @product_categories = ProductCategory.all(order: "running_order")
    
  end

end
